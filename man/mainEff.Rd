% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main_eff.R
\name{mainEff}
\alias{mainEff}
\title{Main Effects}
\usage{
mainEff(BMBobj, fn, rangex, xj, N = 50, res = 100, hdi.params = c(1,
  0.95), ...)
}
\arguments{
\item{BMBobj}{A \code{BayesMassBal} object originally obtained from the \code{\link{BMB}} function.  If \code{is.null(BMBobj$ybal)} then values of \code{ybal} are calculated.  See \code{\link{BMB}}.}

\item{fn}{A character string naming a function with arguments of \code{BMBobj$ybal} and independent random variables x.  See Details for function requirements.}

\item{rangex}{A numeric matrix.  Each column of \code{rangex} contains the minimum and maximum value of uniformly distributed random values making up vector \eqn{x}.}

\item{xj}{Integer indexing the main effect of what elements of \eqn{x} to be found.  If a vector is supplied the marginal main effect of each element is calculated sequentially.  The integers supplied in \code{xj} are equivalent to the indicies of the columns in \code{rangex}.}

\item{N}{Integer specifying the length of the sequence used for \code{xj}.  Larger \code{N} trades a higher resolution of the main effect of \code{xj} for longer computation time and RAM.}

\item{res}{Integer indicating the number of points to be used for each Monte-Carlo integration step.  Larger \code{res} reduces Monte-Carlo variance as the expense of computation time.}

\item{hdi.params}{Numeric vector of length two, used to calculate Highest Posterior Density Intervals (HPDI) of the main effect \code{xj} using \code{\link[HDInterval]{hdi}}. When \code{hdi.params[1] = 1} indicates \code{\link[HDInterval]{hdi}} the mean and HPDI bounds are returned instead of the every sample from the distribution of \eqn{E\lbrack f(x,y)|x_j\rbrack}.  The second element of \code{hdi} is passed to \code{credMass} in the \code{\link[HDInterval]{hdi}}.  The default, \code{hdi.params = c(1,0.95)}, uses 95\% HPDI bounds.}

\item{...}{Extra arguments passed to the named \code{fn}}
}
\value{
A list of \code{length(xj)} list(s).  Each list specifies output for the main effect of a \code{xj}

\item{\code{g}}{The grid used for a particular \code{xj}}

\item{\code{fn.out}}{A matrix giving results on \eqn{E\lbrack f(x,y)|x_j\rbrack}.  If \code{hdi.params[1] = 1}, the mean and HPDI bounds of \eqn{E\lbrack f(x,y)|x_j\rbrack} are returned.  Otherwise, samples of \eqn{E\lbrack f(x,y)|x_j\rbrack} are returned.  The index of each column of \code{fn.out} corresponds to the index of \code{g}}

\item{\code{fn}}{Character string giving the name of the function used.  Same value as argument \code{fn}.}

\item{\code{xj}}{Integer indicating the index of \eqn{x} corresponding to a grouped \code{fn.out} and \code{g}.}
}
\description{
Calculates the main effect of a variable, which is independent of process performance, on a function.
}
\details{
The \code{mainEff} function returns a distribution of \eqn{E\lbrack f(x,y)|x_j\rbrack}, marginalized over the samples of \code{BMBobj$ybal}, giving the distribution of \eqn{E\lbrack f(x,y)|x_j\rbrack} which incorporates uncertainty of a chemical or particulate process.

In the current implementation of \code{mainEff} in the \code{BayesMassBal} package, only uniformly distributed values of \eqn{x} are supported.

The \eqn{f(x,y)} is equivalent to the supplied function named in \code{mainEff(fn)}.  For the arguments of \code{fn}, \code{ybal} is structured in a similar manner as \code{BMBobj$ybal}.  The only difference being individual columns of each matrix are used at a time, and are vectorized.  Note the way \code{ybal} is subset in the example function \code{fn_example}.  The supplied \code{X} is a matrix, with columns corresponding to each element in \eqn{x}.  The output to \code{fn} must be a vector of length \code{nrow(x)}.  The first argument of \code{fn} must be \code{X}, the second argument must be \code{BMBobj$ybal}.  Order of other arguments passed to \code{fn} through \code{...} does not matter. Look at the example closely for details!
}
\examples{

## Importing Data, generating BMB object
y <- massbal.data(file = system.file("extdata", "twonode_example.csv",
                                    package = "BayesMassBal"),
                   header = TRUE, csv.params = list(sep = ";"))

C <- matrix(c(1,-1,0,-1,0,0,1,-1,0,-1), byrow = TRUE, ncol = 5, nrow = 2)
X <- constrain.process(C = C)

BMB_example <- BMB(X = X, y = y, cov.structure = "indep",
                   BTE = c(100,3000,1), lml = FALSE, verb=0)

fn_example <- function(X,ybal){
    cu.frac <- 63.546/183.5
    feed.mass <- ybal$CuFeS2[1] + ybal$gangue[1]
    # Concentrate mass per ton feed
    con.mass <- (ybal$CuFeS2[3] + ybal$gangue[3])/feed.mass
    # Copper mass per ton feed
    cu.mass <- (ybal$CuFeS2[3]*cu.frac)/feed.mass
    gam <- c(-1,-1/feed.mass,cu.mass,-con.mass,-cu.mass,-con.mass)
    f <- X \%*\% gam
    return(f)
    }

rangex <- matrix(c(4.00 ,6.25,1125,1875,3880,9080,20,60,96,208,20.0,62.5),
                  ncol = 6, nrow = 2)
mE_example <- mainEff(BMB_example, fn = "fn_example",rangex =  rangex,xj = 3, N = 25, res = 25)

}
